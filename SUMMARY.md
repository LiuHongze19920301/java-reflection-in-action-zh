# Summary

* [简介](README.md)
* [第一章 基础](contents/chapter1.md)
    * [1.1 反射的值命题](chapter1/reflection's_value_proposition.md)
    * [1.2 程序员 George 的任务](chapter1/enter_george_the_programmer.md)
        * [1.2.1 选择反射](chapter1/chooseing_reflection.md)
        * [1.2.2 实现反射方案](chapter1/programming_a_reflective_solution.md)
    * [1.3 检查运行时的程序](chapter1/examming_running_programs.md)
    * [1.4 在运行时查询方法](chapter1/finding_a_method_at_runtime.md)
    * [1.5 使用 Class 对象表示类型](chapter1/representing_types_with_class_objects.md)
        * [1.5.1 表示原始类型](chapter1/1.5.1_representing_primitive_types.md)
        * [1.5.2 表示接口](chapter1/1.5.2_representing_interfaces.md)
        * [1.5.3 表示数组类型](chapter1/1.5.3_representing_array_types.md)
    * [1.6 理解 Method 对象](chapter1/1.6_understanding_method_objects.md)
        * [1.6.1 使用动态调用](chapter1/1.6.1_using_dynamic_invocation.md)
        * [1.6.2 使用原始类型进行动态调用](chapter1/1.6.2_using_primitives_with_dynamic_invocation.md)
        * [1.6.3 避开调用陷阱](chapter1/1.6.3_avoiding_invocation_pitfalls.md)
    * [1.7 为反射建模](chapter1/1.7_diagramming_for_reflection.md)
    * [1.8 浏览继承层次](chapter1/1.8_navigating_the_inheritance_hierarchy.md)
        * [1.8.1 自省继承层次](chapter1/1.8.1_instrospecting_the_inheritance_hierarchy.md)
        * [1.8.2 意外之处](chapter1/1.8.2_exposing_some_surprises.md)
        * [1.8.3 另外一种反射循环](chapter1/1.8.3_another_reflective_circularity.md)
    * [1.9 总结](chapter1/1.9_summary.md)
* [第二章 通过反射读取字段](contents/chapter2.md)
    * [2.1 序列化对象](chapter2/2.1_serializing_objects.md)
        * [2.1.1 序列化为 XML](chapter2/2.1.1_serializing_to_XML.md)
        * [2.1.2 选择反射](chapter2/2.1.2_choosing_reflection.md)
        * [2.1.3 使用反射设计序列化](chapter2/2.1.3_designing_serialization_with_reflection.md)
    * [2.2 在运行时查找字段](chapter2/2.2_finding_fields_at_runtime.md)
    * [2.3 理解 Filed 对象](chapter2/2.3_understanding_fields_objects.md)
    * [2.4 获取、设置字段值](chapter2/2.4_getting_and_setting_field_values.md)
    * [2.5 检查限定符](chapter2/2.5_examining_modifiers.md)
        * [2.5.1 Member 接口](chapter2/2.5.1_introducing_member.md)
        * [2.5.2 接口自省的陷阱](chapter2/2.5.2_interface_introspection_pitfall.md)
        * [2.5.3 对实例变量进行自省](chapter2/2.5.3_introspecting_for_instance_variables.md)
    * [2.6 访问非公有成员](chapter2/2.6_accessing_nonpublic_members.md)
    * [2.7 处理数组](chapter2/2.7_working_with_arrays.md)
    * [2.8 序列化：完整版](chapter2/2.8_serialization_putting_it_all_together.md)
        * [2.8.1 序列化所有组件](chapter2/2.8.1_serializing_each_component.md)
        * [2.8.2 序列化实例变量](chapter2/2.8.2_serializing_instance_variables.md)
    * [2.9 使用反射序列化](chapter2/2.9_using_reflective_serialization.md)
    * [2.10 总结](chapter2/2.10_summary.md)
* [第三章 动态加载与反射构造](contents/chapter3.md)
    * [3.1 George 的部署难题](chapter3/3.1_georges_deployment_problem.md)
        * [3.1.1 根据模式进行设计](chapter3/3.1.1_designing_with_patterns.md)
        * [3.1.2 实现反射解决方案](chapter3/3.1.2_programming_a_reflective_solution.md)
        * [3.1.3 通过反射增强工厂方法](chapter3/3.1.3_enhancing_the_factory_method_with_reflection.md)
        * [3.1.4 结合代理与反射的优势](chapter3/3.1.4_combining_benefits_of_delegation_and_reflection.md)
    * [3.2 动态加载类](chapter3/3.2_loading_classes_dynamically.md)
        * [3.2.1 forName 基础](chapter3/3.2.1_basics_of_forName.md)
        * [3.2.2 获取数组类](chapter3/3.2.2_getting_array_classes.md)
        * [3.2.3 原始类型与 forName](chapter3/3.2.3_primitives_and_forName.md)
    * [3.3 反射构造对象](chapter3/3.3_constructing_classes_reflectively.md)
        * [3.3.1 反射构造基础](chapter3/3.3.1_reflective_construction_basics.md)
        * [3.3.2 使用构造对象](chapter3/3.3.2_using_constructor_objects.md)
        * [3.3.3 反射构造数组](chapter3/3.3.3_constructing_arrays_reflectively.md)
    * [3.4 设计动态加载](chapter3/3.4_designing_for_dynamic_loading.md)
        * [3.4.1 通过参数反射构造的缺点](chapter3/3.4.1_disadvantages_of_reflective_construction_with_arguments.md)
        * [3.4.2 通过接口初始化](chapter3/3.4.2_initializing_through_an_interface.md)
    * [3.5 实现反序列化](chapter3/3.5_implementing_deserialization.md)
        * [3.5.1 初始化反序列化器](chapter3/3.5.1_initiating_deserialization.md)
        * [3.5.2 构造实例](chapter3/3.5.2_constructing_the_instance.md)
        * [3.5.3 恢复对象结构](chapter3/3.5.3_restoring_the_structure.md)
    * [3.6 George 的序列化：局限](chapter3/3.6_georges_serialization_limitions.md)
        * [3.6.1 无法与 readObject 或 writeObject 交互](chapter3/3.6.1_no_interaction_with_readObject_or_write_Object.md)
        * [3.6.2 未处理 final 类型的实例变量](chapter3/3.6.2_no_handling_of_final_instance_variables.md)
        * [3.6.3 只有无参构造器](chapter3/3.6.3_only_no_argument_constructors.md)
        * [3.6.4 未处理非法 XML 字符](chapter3/3.6.4_no_handling_of_illegal_XML_characters.md)
        * [3.6.5 性能](chapter3/3.6.5_performace.md)
    * [3.7 总结](chapter3/3.7_summary.md)
* [第四章 使用 Java 动态代理](contents/chapter4.md)
* [第五章 调用栈内省](contents/chapter5.md)
* [第六章 使用类加载器](contents/chapter6.md)
* [第七章 反射代码生成](contents/chapter7.md)
* [第八章 设计模式](contents/chapter8.md)
* [第九章 评估性能](contents/chapter9.md)
* [第十章 反射未来展望](contents/chapter10.md)

