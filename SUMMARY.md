# Summary

* [简介](README.md)
* [第一章 基础](contents/chapter1.md)
    * [1.1 反射的值命题](chapter1/reflection's_value_proposition.md)
    * [1.2 程序员 George 的任务](chapter1/enter_george_the_programmer.md)
        * [1.2.1 选择反射](chapter1/chooseing_reflection.md)
        * [1.2.2 实现反射方案](chapter1/programming_a_reflective_solution.md)
    * [1.3 检查运行时的程序](chapter1/examming_running_programs.md)
    * [1.4 在运行时查询方法](chapter1/finding_a_method_at_runtime.md)
    * [1.5 使用 Class 对象表示类型](chapter1/representing_types_with_class_objects.md)
        * [1.5.1 表示原始类型](chapter1/1.5.1_representing_primitive_types.md)
        * [1.5.2 表示接口](chapter1/1.5.2_representing_interfaces.md)
        * [1.5.3 表示数组类型](chapter1/1.5.3_representing_array_types.md)
    * [1.6 理解 Method 对象](chapter1/1.6_understanding_method_objects.md)
        * [1.6.1 使用动态调用](chapter1/1.6.1_using_dynamic_invocation.md)
        * [1.6.2 使用原始类型进行动态调用](chapter1/1.6.2_using_primitives_with_dynamic_invocation.md)
        * [1.6.3 避开调用陷阱](chapter1/1.6.3_avoiding_invocation_pitfalls.md)
    * [1.7 为反射建模](chapter1/1.7_diagramming_for_reflection.md)
    * [1.8 浏览继承层次](chapter1/1.8_navigating_the_inheritance_hierarchy.md)
        * [1.8.1 自省继承层次](chapter1/1.8.1_instrospecting_the_inheritance_hierarchy.md)
        * [1.8.2 意外之处](chapter1/1.8.2_exposing_some_surprises.md)
        * [1.8.3 另外一种反射循环](chapter1/1.8.3_another_reflective_circularity.md)
    * [1.9 总结](chapter1/1.9_summary.md)
* [第二章 通过反射读取字段](contents/chapter2.md)
    * [2.1 序列化对象](chapter2/2.1_serializing_objects.md)
        * [2.1.1 序列化为 XML](chapter2/2.1.1_serializing_to_XML.md)
        * [2.1.2 选择反射](chapter2/2.1.2_choosing_reflection.md)
        * [2.1.3 使用反射设计序列化](chapter2/2.1.3_designing_serialization_with_reflection.md)
    * [2.2 在运行时查找字段](chapter2/2.2_finding_fields_at_runtime.md)
    * [2.3 理解 Filed 对象](chapter2/2.3_understanding_fields_objects.md)
    * [2.4 获取、设置字段值](chapter2/2.4_getting_and_setting_field_values.md)
    * [2.5 检查限定符](chapter2/2.5_examining_modifiers.md)
        * [2.5.1 Member 接口](chapter2/2.5.1_introducing_member.md)
        * [2.5.2 接口自省的陷阱](chapter2/2.5.2_interface_introspection_pitfall.md)
        * [2.5.3 对实例变量进行自省](chapter2/2.5.3_introspecting_for_instance_variables.md)
    * [2.6 访问非公有成员](chapter2/2.6_accessing_nonpublic_members.md)
    * [2.7 处理数组](chapter2/2.7_working_with_arrays.md)
    * [2.8 序列化：完整版](chapter2/2.8_serialization_putting_it_all_together.md)
        * [2.8.1 序列化所有组件](chapter2/2.8.1_serializing_each_component.md)
        * [2.8.2 序列化实例变量](chapter2/2.8.2_serializing_instance_variables.md)
    * [2.9 使用反射序列化](chapter2/2.9_using_reflective_serialization.md)
    * [2.10 总结](chapter2/2.10_summary.md)
* [第三章 动态加载与反射构造](contents/chapter3.md)
* [第四章 使用 Java 动态代理](contents/chapter4.md)
* [第五章 调用栈内省](contents/chapter5.md)
* [第六章 使用类加载器](contents/chapter6.md)
* [第七章 反射代码生成](contents/chapter7.md)
* [第八章 设计模式](contents/chapter8.md)
* [第九章 评估性能](contents/chapter9.md)
* [第十章 反射未来展望](contents/chapter10.md)

