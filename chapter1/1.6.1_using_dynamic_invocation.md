# 1.6.1 使用动态调用

动态调用让程序可以在 **运行时** 调用特定方法，而被调用的方法在 **编译时** 无需确定。

在前面的例子中，下面代码在编译时并 **不知道** 要调用哪个 `setColor` 方法，直到 **运行时** 传入相应参数，才通过自省得到实际调用的方法，之后，查询到的 `setColor` 方法使用 `Method` 对象 `method` 保存：

```
Method method = Object.class.getMethod("setColor", new Class[] { color.class })
```

可以通过 `Method` 对象对象调用 `setColor` 方法：

```
method.invoke(obj, new Object[] { color });
```
* 第一个参数：
	+ 是调用 `setColor` 方法的对象。
	+ 若 `setColor` 方法是 **静态方法**，则该参数将被 **忽略**，因为静态方法 **无需对象调用**。
	+ 若 `setColor` 方法是 **静态方法**，则可以传入 `null`。
* 第二个参数：
	+ 是实际调用 `setColor` 方法使用的参数，为 `Object` 数组。
	+ 对于无参方法，可以传入 **长度为 0 的数组** 或者 `null`。

**如何确定方法？**

只知道 **方法签名** 无法确定一个方法，因为不同类可以定义相同签名的方法，必须通过 **声明方法的类** + **方法签名** 才能唯一确定一个方法。

在反射调用中，**编译时** 确定的 **只有方法签名**，**声明的类** 是在 **运行时** 才知道的。
